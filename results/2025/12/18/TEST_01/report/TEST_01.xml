<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ReportDefinition type="standard">
    <TemplateName>Fortify Security Report</TemplateName>
    <TemplatePath></TemplatePath>
    <LogoPath>/OT_logo.png</LogoPath>
    <Footnote>Copyright 2025 Open Text.</Footnote>
    <UserName></UserName>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Executive Summary</Title>
        <SubSection enabled="true">
            <Title>Issues Overview</Title>
            <Description>This section provides an overview of the issues uncovered during analysis. The report covers a summary of vulnerability categories discovered by the tool. The auditor should augment this section with higher-level conclusions derived from human review of the application (including architecture reviews, black-box testing, compliance issues, etc.)</Description>
            <Text>On 2025. 12. 18., a source code review was performed over the TEST_01 code base. 2 files, 45 LOC (Executable) were scanned and reviewed for defects that could lead to potential security vulnerabilities. A total of 6 reviewed findings were uncovered during the analysis.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issue Summary by Fortify Priority Order</Title>
            <Description>A table summarizing the number of issues found and the breakdown of issues in each Fortify Priority Level</Description>
            <IssueListing listing="false" limit="-1" showShortFileNames="false">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Fortify Priority Order</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="6">
                        <groupTitle>Critical</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
        <SubSection enabled="true">
            <Title>Recommendations and Conclusions</Title>
            <Description>This section gives some high-level recommendations on remediating the issues discussed in the Issues Summary sub section. Recommendations will vary based on deployment scenarios, risk appetite, and existing mitigating strategies. The auditor should supplement the Fortify generic recommendations with specific information that takes into account the application specific variables.</Description>
            <Text>The Issues Category section provides Fortify recommendations for addressing issues at a generic level.  The recommendations for specific fixes can be extrapolated from those generic recommendations by the development group.</Text>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Project Summary</Title>
        <SubSection enabled="true">
            <Title>Code Base Summary</Title>
            <Description>Summary of the Codebase that was analyzed</Description>
            <Text>Code location: /Volumes/Moon/1125/vulnscanner/results/2025/12/18/TEST_01/source/javascript_extracted/javascript
Number of Files: 2
Lines of Code: 45
Build Label: &lt;No Build Label&gt;</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Scan Information</Title>
            <Description>Details of the analysis</Description>
            <Text>Scan time: 00:30
SCA Engine version: 25.3.0.0014
Machine Name: munchanghyeon-ui-MacBookAir
Username running scan: munchanghyeon</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Results Certification</Title>
            <Description>A full summary of the Results Certification for this project</Description>
            <Text>Results Certification Valid

Details:

Results Signature:

	SCA Analysis Results has Valid signature
	

Rules Signature:

	There were no custom rules used in this scan</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Attack Surface</Title>
            <Description>A full summary of the attack surface for this project</Description>
            <Text>Attack Surface:
Private Information:
	null.null.null

System Information:
	null.null.resolve
</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Filter Set Summary</Title>
            <Description>A brief summary of the filterset used to create this report</Description>
            <Text>Current Enabled Filter Set:
Security Auditor View

Filter Set Details:

Folder Filters:
If [fortify priority order] contains critical Then set folder to Critical
If [fortify priority order] contains high Then set folder to High
If [fortify priority order] contains medium Then set folder to Medium
If [fortify priority order] contains low Then set folder to Low</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Audit Guide Summary</Title>
            <Description>Summary of the impact of the audit guide</Description>
            <Text>Audit guide not enabled</Text>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Results Outline</Title>
        <SubSection enabled="true">
            <Title>Overall number of results</Title>
            <Description>Results count</Description>
            <Text>The scan found 6 issues.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Vulnerability Examples by Category</Title>
            <Description>Results summary for critical and high priority issues.  Vulnerability examples are provided by category.</Description>
            <IssueListing listing="true" limit="1" showShortFileNames="false">
                <Refinement>[fortify priority order]:critical OR [fortify priority order]:high</Refinement>
                <Chart chartType="list">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="3">
                        <groupTitle>Cross-Site Scripting: DOM</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>module.js의 changeAnchor() 메서드가 6 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. DOM-based XSS의 경우, URL 매개 변수 또는 브라우저 내 다른 값에서 데이터를 읽어들이며 클라이언트 쪽 코드를 사용하여 페이지에 다시 씁니다. Reflected XSS의 경우 신뢰할 수 없는 소스는 일반적으로 웹 요청이지만, Persisted(Stored 라고도 함) XSS의 경우에는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다. DOM-based XSS의 경우, 피해자의 브라우저가 HTML 페이지를 구문 분석할 때마다 악성 콘텐트가 DOM(Document Object Model) 생성의 일부로 실행됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.

예제 1: 다음 JavaScript 코드 세그먼트는 URL에서 직원 ID인 eid를 읽고 사용자에게 표시합니다.


&lt;SCRIPT&gt;
var pos=document.URL.indexOf("eid=")+4;
document.write(document.URL.substring(pos,document.URL.length));
&lt;/SCRIPT&gt;



예제 2: 다음의 HTML 형식을 고려해 보십시오.


  &lt;div id="myDiv"&gt;
    Employee ID: &lt;input type="text" id="eid"&gt;&lt;br&gt;
    ...
    &lt;button&gt;Show results&lt;/button&gt;
  &lt;/div&gt;
  &lt;div id="resultsDiv"&gt;
    ...
  &lt;/div&gt;


다음 jQuery 코드 세그먼트는 HTML 형식에서 직원 ID를 읽고 사용자에게 표시합니다.


  $(document).ready(function(){
    $("#myDiv").on("click", "button", function(){
      var eid = $("#eid").val();
      $("resultsDiv").append(eid);
      ...
    });
  });


이러한 코드 예제는 ID가 eid인 텍스트 입력에서 직원 ID에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

예제 3: 다음 코드는 React 응용 프로그램 내의 DOM-based XSS 예제를 보여 줍니다.


let element = JSON.parse(getUntrustedInput());
ReactDOM.render(&lt;App&gt;
    {element}
&lt;/App&gt;);


Example 3에서 공격자가 getUntrustedInput()에서 파생된 전체 JSON을 제어할 수 있는 경우 React가 element를 구성 요소로 렌더링하도록 만들 수 있기 때문에 일반적인 Cross-Site Scripting 공격인 자체 제어 값으로 dangerouslySetInnerHTML을 이용하여 개체를 전달할 수 있습니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 하지만 자신의 컴퓨터에서 악의적인 코드가 실행되도록 입력을 제공하는 이유가 있을까요? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어들여 데이터가 동적 콘텐트에 포함됩니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- "&lt;"는 태그가 시작되는 표시이기 때문에 특수합니다

- "&amp;"는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "&gt;"는 일부 브라우저에서 페이지 작성자가 여는 "&lt;"를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- "&amp;"는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- "&amp;"는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- "%" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, "%"는 "%68%65%6C%6C%6F"와 같은 입력이 웹 페이지에 나타날 때 "hello"가 되는 경우 필터링해야 합니다.


&lt;SCRIPT&gt; &lt;/SCRIPT&gt;의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표(")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 "&lt;"가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.

3. React 이전 버전은 전체 구성 요소를 제어하여 cross-site scripting 공격에 더 취약합니다. Symbols를 사용하여 React 구성 요소를 식별하는 최신 버전에서는 악용이 차단됩니다. 하지만 Symbol을 지원(기본적으로 또는 polyfills를 통해)하지 않는 구형 브라우저는 여전히 취약합니다. 다른 Cross-Site Scripting 공격 유형은 모든 브라우저 및 React 버전에 유효합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E254FE67348B46993BB7E0B1D1A01B92" ruleID="AA1656FB-FD4F-4505-B2BE-1B970EE6AAF20">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>module.js의 changeAnchor() 메서드가 6 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>module.js</FileName>
<FilePath>module.js</FilePath>
<LineStart>6</LineStart>
<Snippet>
export function changeAnchor() {
    document.write(document.cookie);
    document.getElementById('myAnchor').href=document.cookie;
}</Snippet>
<TargetFunction>write()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>module.js</FileName>
<FilePath>module.js</FilePath>
<LineStart>6</LineStart>
<Snippet>
export function changeAnchor() {
    document.write(document.cookie);
    document.getElementById('myAnchor').href=document.cookie;
}</Snippet>
<TargetFunction>Read document.cookie()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Privacy Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>module.js 파일은 6 줄의 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우가 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Privacy violation은 다음 경우에 발생합니다.

1. 사용자 개인 정보가 프로그램에 입력됩니다.

2. 데이터는 콘솔, file system 또는 네트워크와 같은 외부 위치에 작성됩니다.


예제 1: 다음 코드는 사용자의 일반 텍스트 비밀번호를 로컬 저장소에 저장합니다.


  localStorage.setItem('password', password);


많은 개발자가 로컬 저장소를 안전한 데이터 장소로 간주하지만 무조건 신뢰해서는 안 됩니다. 특히 개인 정보가 관련된 경우가 대표적입니다.

개인 정보는 다음과 같은 다양한 방식으로 프로그램에 입력됩니다.

- 암호 또는 개인 정보의 형태로 사용자가 직접 입력

- 응용 프로그램이 데이터베이스 또는 기타 데이터 저장소에서 접근

- 협력업체 또는 타사를 통해 간접적으로

개인 정보로 명명되지 않은 데이터도 상황에 따라 개인 정보로 해석될 수 있습니다. 예를 들어, 학생 ID 번호는 명시적이고 공개적으로 각 학생의 개인 정보에 매핑되지 않기 때문에 보통 개인 정보로 간주하지 않습니다. 하지만 학교에서 학생의 주민 등록 번호를 기반으로 ID 번호를 생성하는 경우 ID 번호는 개인 정보로 간주해야 합니다.

보안 및 개인 정보 문제는 서로 상충하는 것처럼 보일 때가 있습니다. 보안 관점에서 보면 이후에 비정상적인 활동을 식별할 수 있도록 모든 중요한 작업을 기록해야 합니다. 하지만 개인 정보가 관련된 경우 이 방법은 위험이 따릅니다.

개인 정보를 위험하게 처리하는 방법은 여러 가지가 있겠지만 공통적인 위험은 잘못된 신뢰에서 비롯됩니다. 프로그래머는 프로그램이 실행되는 운영 환경을 신뢰하기 때문에 개인 정보를 파일 시스템, 레지스트리 또는 기타 로컬로 제어되는 리소스에 저장해도 무방하다고 생각합니다. 하지만 특정 리소스에 대한 액세스가 제한되어 있는 경우에도 액세스 권한을 가진 개인을 신뢰할 수 있다고 보장할 수 없습니다. 일례로, 2004년, AOL의 한 비양심적인 직원이 해외 도박 웹 사이트를 대상으로 영업하는 스패머에게 약 9천 2백만 개의 고객 전자 메일 주소를 팔았습니다[1].

이런 대형 익스플로이트 사건에 대응하여 개인 정보 수집 및 관리에 대한 규제가 점점 엄격해지고 있습니다. 조직의 위치, 업종 및 취급하는 개인 정보의 속성에 따라 조직은 다음의 연방 정부 및 주 정부의 규제를 하나 이상 준수할 의무가 있습니다.

- 세이프 하버 협정(Safe Harbor Privacy Framework)[3]

- GLBA(Gramm-Leach Bliley Act)[4]

- HIPAA(Health Insurance Portability and Accountability Act)[5]

- California SB-1386 [6]

이런 규제에도 불구하고 privacy violation은 우려할 만한 빈도로 계속 발생하고 있습니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>보안과 개인 정보가 충돌할 경우, 보통 개인 정보에 더 높은 우선 순위를 부여해야 합니다. 이를 따르면서 필요한 보안 정보도 유지하기 위해 프로그램을 종료하기 전에 모든 개인 정보를 정리(cleanse)합니다.

훌륭한 개인 정보 관리를 위해서는 내부 개인 정보 지침을 작성하여 엄격하게 준수해야 합니다. 지침에는 응용 프로그램이 개인 정보 데이터를 처리하는 방식을 구체적으로 기술해야 합니다. 조직이 연방법 또는 주법에 따라 규제를 받는 경우, 개인 정보 지침이 법적 요구 사항을 만족하도록 합니다. 조직이 규제를 받지 않는 경우에도 개인 정보를 보호해야 합니다. 그렇지 않으면 고객의 신뢰를 잃을 위험이 있습니다.

개인 정보에 관한 최선의 정책은 노출을 최소화하는 것입니다. 업무 수행에 반드시 필요한 경우를 제외하고 응용 프로그램, 프로세스 및 직원에게 개인 정보에 대한 접근 권한을 부여해서는 안 됩니다. 필요 이상의 권한으로 작업을 수행할 수 없다는 최소 권한 원칙과 함께 개인 정보에 대한 접근을 최소한의 그룹으로 제한하는 것이 좋습니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Privacy Violation에 대비한 철저한 감사의 일환으로 사용자 지정 규칙을 작성하여 프로그램에 입력되는 개인 정보 또는 기타 민감한 정보의 모든 출처를 식별하도록 합니다. 개인 정보 출처 대부분은 자동으로 식별할 수 없습니다. 사용자 지정 규칙이 없으면 privacy violation 검사는 상당히 불완전할 것입니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7793D18293905E4735439B4A1C99A8CA" ruleID="4EB33ACD-A99C-4576-9BF3-FDC866E36D520">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>module.js 파일은 6 줄의 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우가 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>module.js</FileName>
<FilePath>module.js</FilePath>
<LineStart>6</LineStart>
<Snippet>
export function changeAnchor() {
    document.write(document.cookie);
    document.getElementById('myAnchor').href=document.cookie;
}</Snippet>
<TargetFunction>write()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>module.js</FileName>
<FilePath>module.js</FilePath>
<LineStart>6</LineStart>
<Snippet>
export function changeAnchor() {
    document.write(document.cookie);
    document.getElementById('myAnchor').href=document.cookie;
}</Snippet>
<TargetFunction>Read document.cookie()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Open Redirect</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>module.js 파일은 7 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다.

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JavaScript 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 읽어 들인 URL을 열도록 지시합니다.


	...
	strDest = form.dest.value;
	window.open(strDest,"myresults");
	...


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D"

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접 참조를 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL을 생성하여 사용자가 목록에서만 선택할 수 있도록 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL로 채워진 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


...
	strDest = form.dest.value;
	if((strDest.value != null)||(strDest.value.length!=0))
	{
		if((strDest &gt;= 0) &amp;&amp; (strDest &lt;= strURLArray.length -1 ))
		{
			strFinalURL = strURLArray[strDest];
			window.open(strFinalURL,"myresults");
		}
	}
...


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 방지할 수 있습니다.
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="4451B3796DEE98DD05EC12EA196EAE33" ruleID="C71A9777-B31F-4A80-ADED-0868DAE5CF760">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>module.js 파일은 7 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>module.js</FileName>
<FilePath>module.js</FilePath>
<LineStart>7</LineStart>
<Snippet>export function changeAnchor() {
    document.write(document.cookie);
    document.getElementById('myAnchor').href=document.cookie;
}
  </Snippet>
<TargetFunction>Assignment to href()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>module.js</FileName>
<FilePath>module.js</FilePath>
<LineStart>7</LineStart>
<Snippet>export function changeAnchor() {
    document.write(document.cookie);
    document.getElementById('myAnchor').href=document.cookie;
}
  </Snippet>
<TargetFunction>Read document.cookie()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Issue Count by Category</Title>
        <SubSection enabled="true">
            <Title>Issues By Category</Title>
            <IssueListing listing="false" limit="-1" showShortFileNames="false">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="3">
                        <groupTitle>Cross-Site Scripting: DOM</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Privacy Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Open Redirect</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Issue Breakdown by Analysis</Title>
        <SubSection enabled="true">
            <Title>Issue by Analysis</Title>
            <IssueListing listing="false" limit="-1" showShortFileNames="false">
                <Refinement></Refinement>
                <Chart chartType="pie">
                    <Axis>Analysis</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="6">
                        <groupTitle>&lt;none&gt;</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
</ReportDefinition>
